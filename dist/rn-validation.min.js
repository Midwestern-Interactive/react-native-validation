var Validation=function(e){var t={};function n(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(r,a,function(t){return e[t]}.bind(null,a));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}([function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(1).Validation;\n\n//# sourceURL=webpack://Validation/./webpack.index.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/ValidationRules/DefaultRules.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DefaultRules =\n/*#__PURE__*/\nfunction () {\n  function DefaultRules() {\n    _classCallCheck(this, DefaultRules);\n  }\n\n  _createClass(DefaultRules, [{\n    key: \"sometimes\",\n    value: function sometimes(fieldName, value) {\n      if (this.dataset[fieldName] !== undefined) {\n        return true;\n      }\n    }\n  }, {\n    key: \"required\",\n    value: function required(fieldName, value) {\n      return value !== undefined && value !== null && (value > 0 || value.length > 0);\n    }\n  }, {\n    key: \"alpha\",\n    value: function alpha(fieldName, value) {\n      return value.match(/^[\\ a-z]+$/i) !== null;\n    }\n  }, {\n    key: \"alpha_dash\",\n    value: function alpha_dash(fieldName, value) {\n      return value.match(/^[a-z_-]+$/i) !== null;\n    }\n  }, {\n    key: \"alpha_num\",\n    value: function alpha_num(fieldName, value) {\n      return value.match(/^[a-z\\ 0-9]+$/i) !== null;\n    }\n  }, {\n    key: \"email\",\n    value: function email(fieldName, value) {\n      return value.match(/^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/) !== null;\n    }\n  }, {\n    key: \"min\",\n    value: function min(fieldName, value, length) {\n      return value.length > length;\n    }\n  }, {\n    key: \"max\",\n    value: function max(fieldName, value, length) {\n      return value.length < length;\n    }\n  }, {\n    key: \"string\",\n    value: function string(fieldName, value) {\n      return typeof value === 'string';\n    }\n  }, {\n    key: \"confirmed\",\n    value: function confirmed(fieldName, value) {\n      return value === this.fields[fieldName + '_confirmation'];\n    }\n  }, {\n    key: \"in\",\n    value: function _in(fieldName, value, options) {\n      return options.split(',').indexOf(value) !== -1;\n    }\n  }, {\n    key: \"not_in\",\n    value: function not_in(fieldName, value, options) {\n      return options.split(',').indexOf(value) === -1;\n    }\n  }, {\n    key: \"integer\",\n    value: function integer(fieldName, value) {\n      return typeof value === 'number';\n    }\n  }, {\n    key: \"json\",\n    value: function json(fieldName, value) {\n      try {\n        JSON.parse(value);\n      } catch (e) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"digits\",\n    value: function digits(fieldName, value, length) {\n      return typeof value === 'number' && String(value).length === length;\n    }\n  }, {\n    key: \"digits_between\",\n    value: function digits_between(fieldName, value, min, max) {\n      return typeof value === 'number' && String(value).length > min && String(value).length < max;\n    }\n  }, {\n    key: \"accepted\",\n    value: function accepted(fieldName, value) {\n      return [1, 'yes', 'on', true].indexOf(value) !== -1;\n    }\n  }, {\n    key: \"between\",\n    value: function between(fieldName, value, min, max) {\n      return value > min && value < max;\n    }\n  }, {\n    key: \"boolean\",\n    value: function boolean(fieldName, value) {\n      return [true, false, 1, 0, '1', '0'].indexOf(value) !== -1;\n    }\n  }, {\n    key: \"different\",\n    value: function different(fieldName, value, otherFieldName) {\n      return value !== this.dataset[otherFieldName];\n    }\n  }, {\n    key: \"same\",\n    value: function same(fieldName, value, otherFieldName) {\n      return value === this.dataset[otherFieldName];\n    }\n  }, {\n    key: \"filled\",\n    value: function filled(fieldName, value) {\n      if (this.dataset[fieldName] !== undefined) {\n        return value !== undefined && value.length > 0;\n      }\n    }\n  }, {\n    key: \"present\",\n    value: function present(fieldName, value) {\n      return this.dataset[fieldName] !== undefined;\n    }\n  }, {\n    key: \"gt\",\n    value: function gt(fieldName, value, otherFieldName) {\n      return value > this.dataset[otherFieldName];\n    }\n  }, {\n    key: \"gte\",\n    value: function gte(fieldName, value, otherFieldName) {\n      return value >= this.dataset[otherFieldName];\n    }\n  }, {\n    key: \"lt\",\n    value: function lt(fieldName, value, otherFieldName) {\n      return value < this.dataset[otherFieldName];\n    }\n  }, {\n    key: \"lte\",\n    value: function lte(fieldName, value, otherFieldName) {\n      return value <= this.dataset[otherFieldName];\n    }\n  }]);\n\n  return DefaultRules;\n}();\n// CONCATENATED MODULE: ./src/ValidationRules/index.js\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction ValidationRules_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction ValidationRules_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction ValidationRules_createClass(Constructor, protoProps, staticProps) { if (protoProps) ValidationRules_defineProperties(Constructor.prototype, protoProps); if (staticProps) ValidationRules_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\nvar ValidationRules =\n/*#__PURE__*/\nfunction (_DefaultRules) {\n  _inherits(ValidationRules, _DefaultRules);\n\n  function ValidationRules() {\n    var _this;\n\n    var dataset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    ValidationRules_classCallCheck(this, ValidationRules);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ValidationRules).call(this));\n    _this.dataset = dataset;\n    _this.fields = fields;\n    return _this;\n  }\n\n  ValidationRules_createClass(ValidationRules, [{\n    key: \"call\",\n    value: function call(rule) {\n      if (typeof this[rule] === 'function') {\n        return this[rule].bind(this);\n      } else {\n        console.warn('React Native Validation: called unknown validation rule \"' + rule + '\"');\n        return function () {\n          return true;\n        };\n      }\n    }\n  }]);\n\n  return ValidationRules;\n}(DefaultRules);\n// CONCATENATED MODULE: ./src/ErrorHandler/errorMessages/english.js\nvar English = {\n  accepted: 'The :attribute must be accepted.',\n  active_url: 'The :attribute is not a valid URL.',\n  after: 'The :attribute must be a date after :date.',\n  after_or_equal: 'The :attribute must be a date after or equal to :date.',\n  alpha: 'The :attribute may only contain letters.',\n  alpha_dash: 'The :attribute may only contain letters, numbers, dashes and underscores.',\n  alpha_num: 'The :attribute may only contain letters and numbers.',\n  array: 'The :attribute must be an array.',\n  before: 'The :attribute must be a date before :date.',\n  before_or_equal: 'The :attribute must be a date before or equal to :date.',\n  between: {\n    numeric: 'The :attribute must be between :min and :max.',\n    file: 'The :attribute must be between :min and :max kilobytes.',\n    string: 'The :attribute must be between :min and :max characters.',\n    array: 'The :attribute must have between :min and :max items.'\n  },\n  \"boolean\": 'The :attribute field must be true or false.',\n  confirmed: 'The :attribute confirmation does not match.',\n  date: 'The :attribute is not a valid date.',\n  date_equals: 'The :attribute must be a date equal to :date.',\n  date_format: 'The :attribute does not match the format :format.',\n  different: 'The :attribute and :other must be different.',\n  digits: 'The :attribute must be :digits digits.',\n  digits_between: 'The :attribute must be between :min and :max digits.',\n  dimensions: 'The :attribute has invalid image dimensions.',\n  distinct: 'The :attribute field has a duplicate value.',\n  email: 'The :attribute must be a valid email address.',\n  exists: 'The selected :attribute is invalid.',\n  file: 'The :attribute must be a file.',\n  filled: 'The :attribute field must have a value.',\n  gt: {\n    numeric: 'The :attribute must be greater than :value.',\n    file: 'The :attribute must be greater than :value kilobytes.',\n    string: 'The :attribute must be greater than :value characters.',\n    array: 'The :attribute must have more than :value items.'\n  },\n  gte: {\n    numeric: 'The :attribute must be greater than or equal :value.',\n    file: 'The :attribute must be greater than or equal :value kilobytes.',\n    string: 'The :attribute must be greater than or equal :value characters.',\n    array: 'The :attribute must have :value items or more.'\n  },\n  image: 'The :attribute must be an image.',\n  \"in\": 'The selected :attribute is invalid.',\n  in_array: 'The :attribute field does not exist in :other.',\n  integer: 'The :attribute must be an integer.',\n  ip: 'The :attribute must be a valid IP address.',\n  ipv4: 'The :attribute must be a valid IPv4 address.',\n  ipv6: 'The :attribute must be a valid IPv6 address.',\n  json: 'The :attribute must be a valid JSON string.',\n  lt: {\n    numeric: 'The :attribute must be less than :value.',\n    file: 'The :attribute must be less than :value kilobytes.',\n    string: 'The :attribute must be less than :value characters.',\n    array: 'The :attribute must have less than :value items.'\n  },\n  lte: {\n    numeric: 'The :attribute must be less than or equal :value.',\n    file: 'The :attribute must be less than or equal :value kilobytes.',\n    string: 'The :attribute must be less than or equal :value characters.',\n    array: 'The :attribute must not have more than :value items.'\n  },\n  max: {\n    numeric: 'The :attribute may not be greater than :max.',\n    file: 'The :attribute may not be greater than :max kilobytes.',\n    string: 'The :attribute may not be greater than :max characters.',\n    array: 'The :attribute may not have more than :max items.'\n  },\n  mimes: 'The :attribute must be a file of type: :values.',\n  mimetypes: 'The :attribute must be a file of type: :values.',\n  min: {\n    numeric: 'The :attribute must be at least :min.',\n    file: 'The :attribute must be at least :min kilobytes.',\n    string: 'The :attribute must be at least :min characters.',\n    array: 'The :attribute must have at least :min items.'\n  },\n  not_in: 'The selected :attribute is invalid.',\n  not_regex: 'The :attribute format is invalid.',\n  numeric: 'The :attribute must be a number.',\n  present: 'The :attribute field must be present.',\n  regex: 'The :attribute format is invalid.',\n  required: 'The :attribute field is required.',\n  required_if: 'The :attribute field is required when :other is :value.',\n  required_unless: 'The :attribute field is required unless :other is in :values.',\n  required_with: 'The :attribute field is required when :values is present.',\n  required_with_all: 'The :attribute field is required when :values are present.',\n  required_without: 'The :attribute field is required when :values is not present.',\n  required_without_all: 'The :attribute field is required when none of :values are present.',\n  same: 'The :attribute and :other must match.',\n  size: {\n    numeric: 'The :attribute must be :size.',\n    file: 'The :attribute must be :size kilobytes.',\n    string: 'The :attribute must be :size characters.',\n    array: 'The :attribute must contain :size items.'\n  },\n  starts_with: 'The :attribute must start with one of the following: :values',\n  string: 'The :attribute must be a string.',\n  timezone: 'The :attribute must be a valid zone.',\n  unique: 'The :attribute has already been taken.',\n  uploaded: 'The :attribute failed to upload.',\n  url: 'The :attribute format is invalid.',\n  uuid: 'The :attribute must be a valid UUID.'\n};\n// CONCATENATED MODULE: ./src/ErrorHandler/errorMessages/index.js\n\nvar ErrorMessages = {\n  english: English\n};\n// CONCATENATED MODULE: ./src/ErrorHandler/index.js\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ErrorHandler_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction ErrorHandler_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction ErrorHandler_createClass(Constructor, protoProps, staticProps) { if (protoProps) ErrorHandler_defineProperties(Constructor.prototype, protoProps); if (staticProps) ErrorHandler_defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar ErrorHandler_ErrorHandler =\n/*#__PURE__*/\nfunction () {\n  function ErrorHandler() {\n    ErrorHandler_classCallCheck(this, ErrorHandler);\n\n    this.defaultLanguage = 'english';\n    this.currentLanguage = null;\n    this.errorMessages = ErrorMessages;\n  }\n\n  ErrorHandler_createClass(ErrorHandler, [{\n    key: \"extend\",\n    value: function extend(languageObject) {\n      this.errorMessages[languageObject.language] = languageObject.errorMessages;\n    }\n  }, {\n    key: \"setLanguage\",\n    value: function setLanguage(language) {\n      if (this.errorMessages.hasOwnProperty(language)) {\n        this.currentLanguage = language;\n      }\n    }\n  }, {\n    key: \"patchLanguages\",\n    value: function patchLanguages(field, languagePatch) {\n      for (var _i = 0, _Object$keys = Object.keys(languagePatch); _i < _Object$keys.length; _i++) {\n        var language = _Object$keys[_i];\n        this.errorMessages[language] = _objectSpread({}, this.errorMessages[language], {}, _defineProperty({}, field, languagePatch[language]));\n      }\n    }\n  }, {\n    key: \"generate\",\n    value: function generate(rule, ruleParams) {\n      var message = this.errorMessages[this.currentLanguage || this.defaultLanguage][rule];\n      var fieldName = ruleParams.field.replace('_', ' ').replace(/\\b\\w/g, function (l) {\n        return l.toLowerCase();\n      });\n      message = message.replace(':attribute', fieldName);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = ruleParams.params[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var param = _step.value;\n          message = message.replace('VAR1', param);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return message;\n    }\n  }]);\n\n  return ErrorHandler;\n}();\n// CONCATENATED MODULE: ./src/Validation.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Validation\", function() { return Validation_Validation; });\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction Validation_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Validation_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { Validation_typeof = function _typeof(obj) { return typeof obj; }; } else { Validation_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return Validation_typeof(obj); }\n\nfunction Validation_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction Validation_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Validation_createClass(Constructor, protoProps, staticProps) { if (protoProps) Validation_defineProperties(Constructor.prototype, protoProps); if (staticProps) Validation_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar Validation_Validation =\n/*#__PURE__*/\nfunction () {\n  function Validation(rules) {\n    Validation_classCallCheck(this, Validation);\n\n    this.rules = rules;\n    this.errorHandler = new ErrorHandler_ErrorHandler();\n  }\n\n  Validation_createClass(Validation, [{\n    key: \"extendRules\",\n    value: function extendRules(ruleObject) {\n      if (ruleObject.hasOwnProperty('ruleName') && ruleObject.hasOwnProperty('method') && ruleObject.hasOwnProperty('ruleName')) {\n        ValidationRules.prototype[ruleObject.ruleName] = ruleObject.method;\n\n        if (Validation_typeof(ruleObject.errorMessage) === 'object') {\n          this.errorHandler.patchLanguages(ruleObject.ruleName, ruleObject.errorMessage);\n        } else {\n          this.errorHandler.patchLanguages(ruleObject.ruleName, Validation_defineProperty({}, this.errorHandler.defaultLanguage, ruleObject.errorMessage));\n        }\n      } else {\n        console.warn('React Native Validation: passed invalid rule object');\n      }\n    }\n  }, {\n    key: \"extendLanguages\",\n    value: function extendLanguages(languageObject) {\n      this.errorHandler.extend(languageObject);\n    }\n  }, {\n    key: \"setLanguage\",\n    value: function setLanguage(language) {\n      this.errorHandler.setLanguage(language);\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(fields) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        var errors = {};\n        var validationRules = new ValidationRules(_this.rules, fields);\n\n        for (var _i = 0, _Object$keys = Object.keys(_this.rules); _i < _Object$keys.length; _i++) {\n          var field = _Object$keys[_i];\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = _this.rules[field].split('|')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var ruleStatement = _step.value;\n              var rule = ruleStatement.split(':')[0];\n              var parameters = ruleStatement.split(':').slice(1);\n              var results = validationRules.call(rule).apply(void 0, [field, fields[field]].concat(_toConsumableArray(parameters)));\n\n              if (results === false) {\n                if (errors.hasOwnProperty(field) === false) {\n                  errors[field] = [];\n                }\n\n                errors[field].push(_this.errorHandler.generate(rule, {\n                  field: field,\n                  params: parameters\n                }));\n              } else if (results !== true) {\n                break;\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n\n        if (Object.keys(errors).length) {\n          reject(errors);\n        } else {\n          resolve();\n        }\n      });\n    }\n  }]);\n\n  return Validation;\n}();\n\n//# sourceURL=webpack://Validation/./src/Validation.js_+_5_modules?")}]);